{"version":3,"sources":["../src/index.ts","../src/core/EventBus.ts","../src/types/event.ts","../src/types/reader.ts","../src/core/BaseRFIDReader.ts","../src/transports/SerialTransport.ts","../src/transports/TCPTransport.ts","../src/readers/UF3SReader.ts"],"sourcesContent":["export * from './core';\r\nexport * from './types';\r\nexport * from './transports';\r\nexport * from './readers';","import EventEmitter from \"eventemitter3\";\r\nimport { SDKEvent, SDKError } from \"../types/event\";\r\nimport { off } from \"node:cluster\";\r\n\r\nexport class EventBus {\r\n    private emitter = new EventEmitter();\r\n\r\n    on(event: SDKEvent, listener: (...args: any[]) => void): void {\r\n        this.emitter.on(event, listener);\r\n    }\r\n\r\n    off(event: SDKEvent, listener: (...args: any[]) => void): void {\r\n        this.emitter.off(event, listener);\r\n    }\r\n\r\n    emit(event: SDKEvent, payload?: unknown): void {\r\n        this.emitter.emit(event, payload);\r\n    }\r\n\r\n    emitError(error: SDKError): void {\r\n        this.emitter.emit(SDKEvent.ERROR, error);\r\n    }\r\n\r\n    removeAll(): void {\r\n        this.emitter.removeAllListeners();\r\n    }\r\n}\r\n\r\n","export enum SDKEvent {\r\n  CONNECTED = 'connected',\r\n  CONNECTING = 'connecting',\r\n  DISCONNECTED = 'disconnected',\r\n  ERROR = 'error',\r\n\r\n  TAG_DETECTED = 'tag_detected',\r\n  TAG_LOST = 'tag_lost',\r\n\r\n  RAW_DATA = 'raw_data',\r\n  DIAGNOSTIC = 'diagnostic',\r\n}\r\n\r\nexport interface SDKError {\r\n  code: string;\r\n  message: string;\r\n  source?: string;\r\n  raw?: unknown;\r\n}","export enum ReaderState {\n  IDLE = 'idle',\n  //SCANNING = 'scanning',\n  CONNECTED = 'connected',\n  CONNECTING = 'connecting',\n  DISCONNECTED = 'disconnected',\n  ERROR = 'error',\n}\n\nexport interface ReaderInfo {\n    id: string;\n    model: string;\n    transport: 'tcp' | 'serial';\n    address: string;\n    port?: number;\n}","import { EventBus } from './EventBus';\r\nimport { SDKEvent, SDKError } from '../types/event';\r\nimport { ReaderState, ReaderInfo } from '../types/reader';\r\nimport { ITransport } from '../transports/ITransport';\r\n\r\nexport abstract class BaseRFIDReader {\r\n  protected eventBus: EventBus;\r\n  protected transport: ITransport;\r\n  protected state: ReaderState = ReaderState.IDLE;\r\n  protected info: ReaderInfo;\r\n\r\n  constructor(info: ReaderInfo, transport: ITransport, eventBus?: EventBus) {\r\n    this.info = info;\r\n    this.transport = transport;\r\n    this.eventBus = eventBus ?? new EventBus();\r\n\r\n    this.bindTransportEvents();\r\n  }\r\n\r\n  private bindTransportEvents(): void {\r\n    this.transport.onData((data) => this.handleRawData(data));\r\n    this.transport.onError((err) => this.handleError(err));\r\n  }\r\n\r\n  async connect(): Promise<void> {\r\n    try {\r\n      this.state = ReaderState.CONNECTING;\r\n      this.eventBus.emit(SDKEvent.CONNECTING, this.info);\r\n\r\n      await this.transport.connect();\r\n\r\n      this.state = ReaderState.CONNECTED;\r\n      this.eventBus.emit(SDKEvent.CONNECTED, this.info);\r\n    } catch (err) {\r\n      this.handleError(err as Error);\r\n    }\r\n  }\r\n\r\n  async disconnect(): Promise<void> {\r\n    await this.transport.disconnect();\r\n    this.state = ReaderState.DISCONNECTED;\r\n    this.eventBus.emit(SDKEvent.DISCONNECTED, this.info);\r\n  }\r\n\r\n  protected handleRawData(data: Buffer): void {\r\n    this.eventBus.emit(SDKEvent.RAW_DATA, data);\r\n    this.parse(data);\r\n  }\r\n\r\n  protected handleError(err: Error): void {\r\n    this.state = ReaderState.ERROR;\r\n\r\n    const sdkError: SDKError = {\r\n      code: 'READER_ERROR',\r\n      message: err.message,\r\n      source: this.info.model,\r\n      raw: err,\r\n    };\r\n\r\n    this.eventBus.emitError(sdkError);\r\n  }\r\n\r\n  getState(): ReaderState {\r\n    return this.state;\r\n  }\r\n\r\n  getInfo(): ReaderInfo {\r\n    return this.info;\r\n  }\r\n\r\n  getEventBus(): EventBus {\r\n    return this.eventBus;\r\n  }\r\n\r\n  /** Reader-specific protocol parsing */\r\n  protected abstract parse(data: Buffer): void;\r\n}\r\n","import { ITransport, TransportOptions } from './ITransport';\r\nimport { SerialPort } from 'serialport';\r\n\r\nexport class SerialTransport implements ITransport {\r\n  private port: SerialPort;\r\n  private dataCallback: ((data: Buffer) => void) | null = null;\r\n  private errorCallback: ((err: Error) => void) | null = null;\r\n\r\n  constructor(path: string, private baudRate = 115200, private options?: TransportOptions) {\r\n    this.port = new SerialPort({\r\n      path,\r\n      baudRate,\r\n      autoOpen: false,\r\n    });\r\n\r\n    this.port.on('data', (data) => this.dataCallback?.(data));\r\n    this.port.on('error', (err) => this.errorCallback?.(err));\r\n  }\r\n\r\n  connect(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      this.port.open((err) => {\r\n        if (err) return reject(err);\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n\r\n  disconnect(): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      if (!this.port.isOpen) return resolve();\r\n      this.port.close(() => resolve());\r\n    });\r\n  }\r\n\r\nsend(data: Buffer | string): Promise<void> {\r\n  return new Promise((resolve, reject) => {\r\n    if (!this.port.isOpen) return reject(new Error('Serial port not open'));\r\n\r\n    const bufferToSend = typeof data === 'string' ? Buffer.from(data, 'utf-8') : data;\r\n\r\n    this.port.write(bufferToSend, (err) => {\r\n      if (err) return reject(err);\r\n      resolve();\r\n    });\r\n  });\r\n}\r\n\r\n\r\n  onData(callback: (data: Buffer) => void): void {\r\n    this.dataCallback = callback;\r\n  }\r\n\r\n  onError(callback: (err: Error) => void): void {\r\n    this.errorCallback = callback;\r\n  }\r\n\r\n  isConnected(): boolean {\r\n    return this.port.isOpen;\r\n  }\r\n}\r\n","import net from 'net';\nimport { ITransport, TransportOptions } from './ITransport';\n\nexport class TCPTransport implements ITransport {\n  private host: string;\n  private port: number;\n  private socket?: net.Socket;\n  private connected = false;\n\n  private dataCallback: ((data: Buffer) => void) | null = null;\n  private errorCallback: ((err: Error) => void) | null = null;\n\n  constructor(host: string, port: number, private options?: TransportOptions) {\n    this.host = host;\n    this.port = port;\n  }\n\n  connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.socket = new net.Socket();\n\n      this.socket.on('connect', () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.socket.on('data', (data) => {\n        const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data);\n        this.dataCallback?.(buffer);\n      });\n\n      this.socket.on('error', (err) => {\n        this.errorCallback?.(err);\n        reject(err);\n      });\n\n      this.socket.on('close', () => {\n        this.connected = false;\n      });\n\n      this.socket.connect(this.port, this.host);\n    });\n  }\n\n  disconnect(): Promise<void> {\n    return new Promise((resolve) => {\n      if (!this.socket) return resolve();\n\n      this.socket.once('close', () => {\n        this.connected = false;\n        resolve();\n      });\n\n      this.socket.end();\n      this.socket.destroy();\n    });\n  }\n\n  send(data: Buffer): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.connected) return reject(new Error('TCP not connected'));\n      this.socket.write(data, (err) => {\n        if (err) return reject(err);\n        resolve();\n      });\n    });\n  }\n\n  onData(callback: (data: Buffer) => void): void {\n    this.dataCallback = callback;\n  }\n\n  onError(callback: (err: Error) => void): void {\n    this.errorCallback = callback;\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n}\n","import { BaseRFIDReader } from '../core/BaseRFIDReader';\r\nimport { ITransport } from '../transports/ITransport';\r\nimport { ReaderInfo } from '../types/reader';\r\nimport { SDKEvent } from '../types/event';\r\n\r\n/**\r\n * UF3-S Reader Protocol:\r\n * - Sends tag data as fixed-length packets\r\n * - Each tag usually ends with \\r\\n\r\n * - Example: \"E2000017221101441890\\r\\n\"\r\n */\r\n\r\n\r\nexport class UF3SReader extends BaseRFIDReader {\r\n  private buffer = '';\r\n\r\n  protected parse(data: Buffer): void {\r\n    // Append incoming data to buffer\r\n    this.buffer += data.toString('utf-8');\r\n\r\n    // Check for full packets (ending with \\r\\n)\r\n    let index: number;\r\n    while ((index = this.buffer.indexOf('\\r\\n')) >= 0) {\r\n      const rawTag = this.buffer.slice(0, index).trim();\r\n      this.buffer = this.buffer.slice(index + 2);\r\n\r\n      if (rawTag) {\r\n        // Emit TAG_DETECTED event\r\n        this.getEventBus().emit(SDKEvent.TAG_DETECTED, {\r\n          tagId: rawTag,\r\n          reader: this.getInfo(),\r\n          timestamp: new Date(),\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","names":["SDKEvent","EventEmitter","ReaderState","net"]}