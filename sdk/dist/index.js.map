{"version":3,"sources":["../src/index.ts","../src/core/EventBus.ts","../src/types/event.ts","../src/types/reader.ts","../src/core/BaseRFIDReader.ts","../src/transports/SerialTransport.ts","../src/transports/TCPTransport.ts","../src/readers/UF3SReader.ts","../src/diagnostics/PortDiscovery.ts"],"sourcesContent":["export * from './core';\r\nexport * from './types';\r\nexport * from './transports';\r\nexport * from './readers';\r\nexport * from './diagnostics';","import EventEmitter from \"eventemitter3\";\r\nimport { SDKEvent, SDKError } from \"../types/event\";\r\n\r\n/**\r\n * Type-safe event listener signatures\r\n */\r\nexport interface EventListeners {\r\n  [SDKEvent.CONNECTED]: (info: any) => void;\r\n  [SDKEvent.CONNECTING]: (info: any) => void;\r\n  [SDKEvent.DISCONNECTED]: (info: any) => void;\r\n  [SDKEvent.ERROR]: (error: SDKError) => void;\r\n  [SDKEvent.TAG_DETECTED]: (data: any) => void;\r\n  [SDKEvent.TAG_LOST]: (data: any) => void;\r\n  [SDKEvent.RAW_DATA]: (data: Buffer) => void;\r\n  [SDKEvent.DIAGNOSTIC]: (data: any) => void;\r\n}\r\n\r\n/**\r\n * Enhanced EventBus with proper event handling\r\n * Provides type-safe event emission and subscription\r\n */\r\nexport class EventBus {\r\n  private emitter = new EventEmitter();\r\n  private listeners: Map<SDKEvent, Set<Function>> = new Map();\r\n  private errorHandlers: Set<(error: SDKError) => void> = new Set();\r\n  private maxListeners = 100;\r\n\r\n  constructor(maxListeners = 100) {\r\n    this.maxListeners = maxListeners;\r\n  }\r\n\r\n  /**\r\n   * Subscribe to an event\r\n   * @param event - The event to listen to\r\n   * @param listener - The callback function\r\n   * @returns Unsubscribe function for convenience\r\n   */\r\n  on<E extends SDKEvent>(\r\n    event: E,\r\n    listener: EventListeners[E]\r\n  ): () => void {\r\n    this.emitter.on(event, listener);\r\n\r\n    // Track listener for debugging/cleanup\r\n    if (!this.listeners.has(event)) {\r\n      this.listeners.set(event, new Set());\r\n    }\r\n    this.listeners.get(event)!.add(listener);\r\n\r\n    // Return unsubscribe function\r\n    return () => this.off(event, listener);\r\n  }\r\n\r\n  /**\r\n   * Subscribe to an event only once\r\n   * @param event - The event to listen to\r\n   * @param listener - The callback function\r\n   */\r\n  once<E extends SDKEvent>(\r\n    event: E,\r\n    listener: EventListeners[E]\r\n  ): void {\r\n    this.emitter.once(event, listener);\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from an event\r\n   * @param event - The event to unsubscribe from\r\n   * @param listener - The callback function to remove\r\n   */\r\n  off<E extends SDKEvent>(\r\n    event: E,\r\n    listener: EventListeners[E]\r\n  ): void {\r\n    this.emitter.off(event, listener);\r\n\r\n    // Remove from tracking\r\n    if (this.listeners.has(event)) {\r\n      this.listeners.get(event)!.delete(listener);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   * @param event - The event to emit\r\n   * @param payload - The data to send with the event\r\n   */\r\n  emit<E extends SDKEvent>(event: E, payload?: any): boolean {\r\n    return this.emitter.emit(event, payload);\r\n  }\r\n\r\n  /**\r\n   * Emit an error event\r\n   * @param error - The error to emit\r\n   */\r\n  emitError(error: SDKError): void {\r\n    // Emit to error event listeners\r\n    this.emitter.emit(SDKEvent.ERROR, error);\r\n\r\n    // Also call specialized error handlers\r\n    for (const handler of this.errorHandlers) {\r\n      try {\r\n        handler(error);\r\n      } catch (err) {\r\n        console.error('Error in error handler:', err);\r\n      }\r\n    }\r\n\r\n    // Log warning if no error listeners\r\n    if (this.listenerCount(SDKEvent.ERROR) === 0 && this.errorHandlers.size === 0) {\r\n      console.warn('Unhandled SDK error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register a global error handler\r\n   * @param handler - The error handler function\r\n   */\r\n  onError(handler: (error: SDKError) => void): () => void {\r\n    this.errorHandlers.add(handler);\r\n    return () => this.errorHandlers.delete(handler);\r\n  }\r\n\r\n  /**\r\n   * Remove all listeners for an event or all events\r\n   * @param event - The specific event to clear, or undefined to clear all\r\n   */\r\n  removeAllListeners(event?: SDKEvent): void {\r\n    if (event) {\r\n      this.emitter.removeAllListeners(event);\r\n      this.listeners.delete(event);\r\n    } else {\r\n      this.emitter.removeAllListeners();\r\n      this.listeners.clear();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the number of listeners for an event\r\n   * @param event - The event to check\r\n   */\r\n  listenerCount(event: SDKEvent): number {\r\n    return this.emitter.listenerCount(event);\r\n  }\r\n\r\n  /**\r\n   * Get all events with active listeners\r\n   */\r\n  getActiveEvents(): SDKEvent[] {\r\n    const active: SDKEvent[] = [];\r\n    for (const [event, listeners] of this.listeners.entries()) {\r\n      if (listeners.size > 0) {\r\n        active.push(event);\r\n      }\r\n    }\r\n    return active;\r\n  }\r\n\r\n  /**\r\n   * Get listener details for debugging\r\n   */\r\n  getListenerDetails(): Record<string, number> {\r\n    const details: Record<string, number> = {};\r\n    for (const [event, listeners] of this.listeners.entries()) {\r\n      if (listeners.size > 0) {\r\n        details[event] = listeners.size;\r\n      }\r\n    }\r\n    return details;\r\n  }\r\n\r\n  /**\r\n   * Wait for a specific event to be emitted\r\n   * @param event - The event to wait for\r\n   * @param timeout - Optional timeout in ms\r\n   */\r\n  waitFor<E extends SDKEvent>(\r\n    event: E,\r\n    timeout?: number\r\n  ): Promise<any> {\r\n    return new Promise((resolve, reject) => {\r\n      let timeoutHandle: NodeJS.Timeout | null = null;\r\n\r\n      const listener = (payload: any) => {\r\n        if (timeoutHandle) clearTimeout(timeoutHandle);\r\n        this.off(event, listener);\r\n        resolve(payload);\r\n      };\r\n\r\n      if (timeout) {\r\n        timeoutHandle = setTimeout(() => {\r\n          this.off(event, listener);\r\n          reject(new Error(`Timeout waiting for event: ${event}`));\r\n        }, timeout);\r\n      }\r\n\r\n      this.on(event, listener);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create a scoped event bus for a specific context\r\n   * Useful for isolated event handling\r\n   */\r\n  createScope(): EventBus {\r\n    return new EventBus(this.maxListeners);\r\n  }\r\n\r\n  /**\r\n   * Clean up and destroy the event bus\r\n   */\r\n  destroy(): void {\r\n    this.errorHandlers.clear();\r\n    this.removeAllListeners();\r\n    this.listeners.clear();\r\n  }\r\n}\r\n\r\n","export enum SDKEvent {\r\n  CONNECTED = 'connected',\r\n  CONNECTING = 'connecting',\r\n  DISCONNECTED = 'disconnected',\r\n  ERROR = 'error',\r\n\r\n  TAG_DETECTED = 'tag_detected',\r\n  TAG_LOST = 'tag_lost',\r\n\r\n  RAW_DATA = 'raw_data',\r\n  DIAGNOSTIC = 'diagnostic',\r\n}\r\n\r\nexport interface SDKError {\r\n  code: string;\r\n  message: string;\r\n  source?: string;\r\n  raw?: unknown;\r\n}","export enum ReaderState {\n  IDLE = 'idle',\n  //SCANNING = 'scanning',\n  CONNECTED = 'connected',\n  CONNECTING = 'connecting',\n  DISCONNECTED = 'disconnected',\n  ERROR = 'error',\n}\n\nexport interface ReaderInfo {\n    id: string;\n    model: string;\n    transport: 'tcp' | 'serial';\n    address: string;\n    port?: number;\n}","import { EventBus } from './EventBus';\r\nimport { SDKEvent, SDKError } from '../types/event';\r\nimport { ReaderState, ReaderInfo } from '../types/reader';\r\nimport { ITransport } from '../transports/ITransport';\r\n\r\nexport abstract class BaseRFIDReader {\r\n  protected eventBus: EventBus;\r\n  protected transport: ITransport;\r\n  protected state: ReaderState = ReaderState.IDLE;\r\n  protected info: ReaderInfo;\r\n\r\n  constructor(info: ReaderInfo, transport: ITransport, eventBus?: EventBus) {\r\n    this.info = info;\r\n    this.transport = transport;\r\n    this.eventBus = eventBus ?? new EventBus();\r\n\r\n    this.bindTransportEvents();\r\n  }\r\n\r\n  private bindTransportEvents(): void {\r\n    this.transport.onData((data) => this.handleRawData(data));\r\n    this.transport.onError((err) => this.handleError(err));\r\n  }\r\n\r\n  async connect(): Promise<void> {\r\n    try {\r\n      this.state = ReaderState.CONNECTING;\r\n      this.eventBus.emit(SDKEvent.CONNECTING, this.info);\r\n\r\n      await this.transport.connect();\r\n\r\n      this.state = ReaderState.CONNECTED;\r\n      this.eventBus.emit(SDKEvent.CONNECTED, this.info);\r\n    } catch (err) {\r\n      this.handleError(err as Error);\r\n    }\r\n  }\r\n\r\n  async disconnect(): Promise<void> {\r\n    await this.transport.disconnect();\r\n    this.state = ReaderState.DISCONNECTED;\r\n    this.eventBus.emit(SDKEvent.DISCONNECTED, this.info);\r\n  }\r\n\r\n  protected handleRawData(data: Buffer): void {\r\n    this.eventBus.emit(SDKEvent.RAW_DATA, data);\r\n    this.parse(data);\r\n  }\r\n\r\n  protected handleError(err: Error): void {\r\n    this.state = ReaderState.ERROR;\r\n\r\n    const sdkError: SDKError = {\r\n      code: 'READER_ERROR',\r\n      message: err.message,\r\n      source: this.info.model,\r\n      raw: err,\r\n    };\r\n\r\n    this.eventBus.emitError(sdkError);\r\n  }\r\n\r\n  getState(): ReaderState {\r\n    return this.state;\r\n  }\r\n\r\n  getInfo(): ReaderInfo {\r\n    return this.info;\r\n  }\r\n\r\n  getEventBus(): EventBus {\r\n    return this.eventBus;\r\n  }\r\n\r\n  /** Reader-specific protocol parsing */\r\n  protected abstract parse(data: Buffer): void;\r\n}\r\n","import { ITransport, TransportOptions } from './ITransport';\r\nimport { SerialPort } from 'serialport';\r\n\r\nexport interface SerialTransportOptions extends TransportOptions {\r\n  dataBits?: 8 | 7 | 6 | 5;\r\n  stopBits?: 1 | 2;\r\n  parity?: 'none' | 'even' | 'odd';\r\n}\r\n\r\n/**\r\n * Serial Port Transport Implementation\r\n * Handles communication with RFID readers via RS-232/RS-485 serial connections\r\n */\r\nexport class SerialTransport implements ITransport {\r\n  private port: SerialPort;\r\n  private dataCallback: ((data: Buffer) => void) | null = null;\r\n  private errorCallback: ((err: Error) => void) | null = null;\r\n  private connected = false;\r\n\r\n  constructor(\r\n    path: string,\r\n    private baudRate = 115200,\r\n    private options?: SerialTransportOptions\r\n  ) {\r\n    this.port = new SerialPort({\r\n      path,\r\n      baudRate,\r\n      dataBits: options?.dataBits ?? 8,\r\n      stopBits: options?.stopBits ?? 1,\r\n      parity: options?.parity ?? 'none',\r\n      autoOpen: false,\r\n    });\r\n\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    this.port.on('data', (data: Buffer) => {\r\n      this.dataCallback?.(data);\r\n    });\r\n\r\n    this.port.on('error', (err: Error) => {\r\n      this.connected = false;\r\n      this.errorCallback?.(err);\r\n    });\r\n\r\n    this.port.on('close', () => {\r\n      this.connected = false;\r\n    });\r\n\r\n    this.port.on('open', () => {\r\n      this.connected = true;\r\n    });\r\n  }\r\n\r\n  connect(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (this.connected) return resolve();\r\n\r\n      this.port.open((err) => {\r\n        if (err) {\r\n          this.connected = false;\r\n          return reject(new Error(`Failed to open serial port: ${err.message}`));\r\n        }\r\n        this.connected = true;\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n\r\n  disconnect(): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.connected) return resolve();\r\n\r\n      this.port.close((err) => {\r\n        if (err) {\r\n          return reject(new Error(`Failed to close serial port: ${err.message}`));\r\n        }\r\n        this.connected = false;\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n\r\n  send(data: Buffer): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.connected || !this.port.isOpen) {\r\n        return reject(new Error('Serial port not open'));\r\n      }\r\n\r\n      this.port.write(data, (err) => {\r\n        if (err) return reject(err);\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n\r\n  onData(callback: (data: Buffer) => void): void {\r\n    this.dataCallback = callback;\r\n  }\r\n\r\n  onError(callback: (err: Error) => void): void {\r\n    this.errorCallback = callback;\r\n  }\r\n\r\n  isConnected(): boolean {\r\n    return this.connected && this.port.isOpen;\r\n  }\r\n\r\n  /**\r\n   * Get list of available serial ports\r\n   * Useful for discovering connected RFID readers\r\n   */\r\n  static async listPorts(): Promise<Array<{ path: string; manufacturer?: string }>> {\r\n    try {\r\n      return await SerialPort.list();\r\n    } catch (err) {\r\n      throw new Error(`Failed to list serial ports: ${(err as Error).message}`);\r\n    }\r\n  }\r\n}\r\n","import net from 'net';\nimport { ITransport, TransportOptions } from './ITransport';\n\nexport class TCPTransport implements ITransport {\n  private host: string;\n  private port: number;\n  private socket?: net.Socket;\n  private connected = false;\n\n  private dataCallback: ((data: Buffer) => void) | null = null;\n  private errorCallback: ((err: Error) => void) | null = null;\n\n  constructor(host: string, port: number, private options?: TransportOptions) {\n    this.host = host;\n    this.port = port;\n  }\n\n  connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.socket = new net.Socket();\n\n      this.socket.on('connect', () => {\n        this.connected = true;\n        resolve();\n      });\n\n      this.socket.on('data', (data) => {\n        const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data);\n        this.dataCallback?.(buffer);\n      });\n\n      this.socket.on('error', (err) => {\n        this.errorCallback?.(err);\n        reject(err);\n      });\n\n      this.socket.on('close', () => {\n        this.connected = false;\n      });\n\n      this.socket.connect(this.port, this.host);\n    });\n  }\n\n  disconnect(): Promise<void> {\n    return new Promise((resolve) => {\n      if (!this.socket) return resolve();\n\n      this.socket.once('close', () => {\n        this.connected = false;\n        resolve();\n      });\n\n      this.socket.end();\n      this.socket.destroy();\n    });\n  }\n\n  send(data: Buffer): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.connected) return reject(new Error('TCP not connected'));\n      this.socket.write(data, (err) => {\n        if (err) return reject(err);\n        resolve();\n      });\n    });\n  }\n\n  onData(callback: (data: Buffer) => void): void {\n    this.dataCallback = callback;\n  }\n\n  onError(callback: (err: Error) => void): void {\n    this.errorCallback = callback;\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n}\n","import { BaseRFIDReader } from '../core/BaseRFIDReader';\r\nimport { ITransport } from '../transports/ITransport';\r\nimport { ReaderInfo } from '../types/reader';\r\nimport { SDKEvent } from '../types/event';\r\n\r\n/**\r\n * UF3-S Reader Protocol:\r\n * - Sends tag data as fixed-length packets\r\n * - Each tag usually ends with \\r\\n\r\n * - Example: \"E2000017221101441890\\r\\n\"\r\n */\r\n\r\n\r\nexport class UF3SReader extends BaseRFIDReader {\r\n  private buffer = '';\r\n\r\n  protected parse(data: Buffer): void {\r\n    // Append incoming data to buffer\r\n    this.buffer += data.toString('utf-8');\r\n\r\n    // Check for full packets (ending with \\r\\n)\r\n    let index: number;\r\n    while ((index = this.buffer.indexOf('\\r\\n')) >= 0) {\r\n      const rawTag = this.buffer.slice(0, index).trim();\r\n      this.buffer = this.buffer.slice(index + 2);\r\n\r\n      if (rawTag) {\r\n        // Emit TAG_DETECTED event\r\n        this.getEventBus().emit(SDKEvent.TAG_DETECTED, {\r\n          tagId: rawTag,\r\n          reader: this.getInfo(),\r\n          timestamp: new Date(),\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { SerialTransport } from '../transports/SerialTransport';\r\nimport { TCPTransport } from '../transports/TCPTransport';\r\nimport { ReaderInfo } from '../types/reader';\r\n\r\n/**\r\n * Port Discovery Utility\r\n * Helps discover and list available serial and TCP ports\r\n */\r\nexport class PortDiscovery {\r\n  /**\r\n   * List all available serial ports\r\n   */\r\n  static async listSerialPorts(): Promise<Array<{ path: string; manufacturer?: string }>> {\r\n    try {\r\n      return await SerialTransport.listPorts();\r\n    } catch (err) {\r\n      console.error('Error listing serial ports:', err);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Scan for TCP readers on a network range\r\n   * @param startIP - Starting IP address (e.g., \"192.168.1.1\")\r\n   * @param endIP - Ending IP address (e.g., \"192.168.1.255\")\r\n   * @param port - Port to scan (default 8088 for UF3-S)\r\n   * @param timeout - Connection timeout in ms (default 1000)\r\n   */\r\n  static async scanTCPNetwork(\r\n    startIP: string,\r\n    endIP: string,\r\n    port: number = 8088,\r\n    timeout: number = 1000\r\n  ): Promise<ReaderInfo[]> {\r\n    const foundReaders: ReaderInfo[] = [];\r\n    const ips = this.generateIPRange(startIP, endIP);\r\n\r\n    const scanPromises = ips.map((ip) =>\r\n      this.testTCPConnection(ip, port, timeout)\r\n        .then((success) => {\r\n          if (success) {\r\n            foundReaders.push({\r\n              id: `tcp-${ip}-${port}`,\r\n              model: 'UF3-S',\r\n              transport: 'tcp',\r\n              address: ip,\r\n              port,\r\n            });\r\n          }\r\n        })\r\n        .catch(() => {\r\n          // Silent fail, continue scanning\r\n        })\r\n    );\r\n\r\n    await Promise.all(scanPromises);\r\n    return foundReaders;\r\n  }\r\n\r\n  /**\r\n   * Test TCP connection to a specific address\r\n   */\r\n  private static testTCPConnection(\r\n    host: string,\r\n    port: number,\r\n    timeout: number\r\n  ): Promise<boolean> {\r\n    return new Promise((resolve) => {\r\n      const timer = setTimeout(() => resolve(false), timeout);\r\n\r\n      const transport = new TCPTransport(host, port);\r\n      transport\r\n        .connect()\r\n        .then(() => {\r\n          clearTimeout(timer);\r\n          transport.disconnect();\r\n          resolve(true);\r\n        })\r\n        .catch(() => {\r\n          clearTimeout(timer);\r\n          resolve(false);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate array of IP addresses from range\r\n   */\r\n  private static generateIPRange(startIP: string, endIP: string): string[] {\r\n    const ips: string[] = [];\r\n    const [start1, start2, start3, start4] = startIP.split('.').map(Number);\r\n    const [end1, end2, end3, end4] = endIP.split('.').map(Number);\r\n\r\n    for (let i = start4; i <= end4; i++) {\r\n      ips.push(`${start1}.${start2}.${start3}.${i}`);\r\n    }\r\n\r\n    return ips;\r\n  }\r\n\r\n  /**\r\n   * Get suggested reader configuration from discovered port\r\n   */\r\n  static createReaderInfo(\r\n    path: string,\r\n    model: string = 'UF3-S',\r\n    transport: 'serial' | 'tcp' = 'serial'\r\n  ): ReaderInfo {\r\n    return {\r\n      id: `${transport}-${path}`,\r\n      model,\r\n      transport,\r\n      address: path,\r\n      ...(transport === 'tcp' && { port: 8088 }),\r\n    };\r\n  }\r\n}\r\n"],"mappings":"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","names":["SDKEvent","EventEmitter","ReaderState","net"]}